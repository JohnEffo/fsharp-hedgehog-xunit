# fsharp-hedgehog-xunit

[![][nuget-shield]][nuget] [![][workflow-shield]][workflow] [![Coverage Status](https://coveralls.io/repos/github/dharmaturtle/fsharp-hedgehog-xunit/badge.svg?branch=main)](https://coveralls.io/github/dharmaturtle/fsharp-hedgehog-xunit?branch=main)

[Hedgehog][hedgehog] with convenience attributes for [xUnit.net][xunit].

<img src="https://github.com/hedgehogqa/fsharp-hedgehog/raw/master/img/hedgehog-logo.png" width="307" align="right"/>

## Features

- Test method arguments generated by the customizable [`GenX.auto`](https://github.com/hedgehogqa/fsharp-hedgehog-experimental/#auto-generation).
- `Property.check` called for each test.


## Getting Started

Install the _Hedgehog.Xunit_ [package][nuget] from Visual Studio's Package Manager Console:

```powershell
PM> Install-Package Hedgehog.Xunit
```

Suppose you have a test that uses [Hedgehog.Experimental](https://github.com/hedgehogqa/fsharp-hedgehog-experimental) and looks similar to the following:

```CSharp
using Hedgehog;
using Hedgehog.Linq;
using Hedgehog.Xunit;
using Property = Hedgehog.Linq.Property;

public class DocumentationSamples
{
  [Fact]
  public void Reversing_a_list_twice_yields_the_original_list()
  {
    var gen = GenX.auto<List<int>>();
    var prop = from data in Property.ForAll(gen)
      let testList = Enumerable.Reverse(data).Reverse().ToList()
      select Assert.Equivalent(data, testList, true);
    prop.Check();
  }
}
```

Then using Hedgehog.Xunit, you can simplify the above test to

```CSharp
[Property]
public void Reversing_a_list_twice_yields_the_original_list_with_xunit(List<int> xs)
{
    var testList = Enumerable.Reverse(xs).ToList();
    Assert.Equivalent(xs, testList, true);
}
```

## Documentation

`Hedgehog.Xunit` provides the following attributes:
* [Property](#properties-attribute)  
Converts an XUnit `Fact` into a property, allowing you to easily configure property parameters.
* [Properties](#properties-attribute)  
Allows the easy configuration of all properties in a test suite.
* [Recheck](#recheck-attribute)  
Rerun a particular test case. 
* [ParameterGenerator](#parametergenerator)  Control what generator is used on a parameter by parameter basis. configure 

> All code in the below is available [here](/examples/csharp-examples/DocumentationSamples.cs) 

### `Property` attribute
---
* Methods with the `Property` attribute have their arguments automatically generated by [`GenX.auto`](https://github.com/hedgehogqa/fsharp-hedgehog-experimental/#auto-generation); the generator used can be customised by either [AutogenConfig](#autogenconfig) or [PrameterGenerator](#parametergenerator)

  ```C#
  [Property]
  public void Can_generate_an_int(
    int i)
  {
    _output.WriteLine($"Test input: {i}");
  }
  ```
  ---
  ```
  === Output ===
  Test input: 0
  Test input: -1
  Test input: 1
  ...
  Test input: 522317518
  Test input: 404306656
  Test input: 1550509078
  ```

* If the method return a Boolean then that is considered a property 

  ```CSharp
  [Property(Skip = "For documentation purposes")]
  public bool Will_fail(
    bool value) => value;
  ```
  ```
  System.Exception
  *** Failed! Falsifiable (after 4 tests):
  [false]
  Hedgehog.Xunit.TestReturnedFalseException: Test returned `false`.
  ...
  ```

* Async and not async `Task<Boolean>` are also considered properties

  ```CSharp
    internal static Task Fast()
    {
      return Task.CompletedTask;
    }
    
    [Property]
    public async Task<bool> Async_boolean(bool i)
    {
      await Fast();
      return i || !i;
    }

    [Property]
    public  Task<bool> Task_boolean(bool i)
    {
        return Task.FromResult(i || !i);
    }
  ```

* If the property returns void then it should throw on failure like a normal unit test

  ```CSharp
    [Property]
    public void Will_fail_by_assertion(
      bool value) => Assert.True(value, "All booleans values should be true!");
  ```
  ```
  System.Exception
  *** Failed! Falsifiable (after 2 tests):
  [false]
  System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.
  ---> Xunit.Sdk.TrueException: All booleans values should be true!
  Expected: True
  Actual:   False
  ```

* If the property returns task it is considered a property and should throw an exception if the test fails

    ```CSharp
    internal static Task Fast()
    {
      return Task.CompletedTask;
    }

    [Property]
    public async Task Async_Task_property(
      int i)
    {
      await Fast();
      Assert.True(i == i);
    }

    [Property]
    public Task Task_property(
      int i)
    {
      Assert.True(i == i);
      return Task.CompletedTask;
    }
    ```

### `Property` Configuration
---
The `Property` attribute's constructor may take several arguments:   
* [`AutoGenConfig`](#autogenconfig): Allow the manual control of generators
* [`Tests`](#tests-count): Specifies the number of tests to run 
* [`Shrinks`](#shrinks-count): Specifies the number of shrinks

The `Property` attribute extends `Xunit.FactAttribute`,  so it may also take `DisplayName`, `Skip`, and `Timeout`.

#### `AutoGenConfig`
---
The default generator used to create arguments is `GenX.defaults`. To specify different generators:
* Create a class with a single static property or method that returns an instance of `AutoGenConfig`. 
* Provide the type of this class as an argument to the `Property` attribute. This works around the constraint that [`Attribute` parameters must be a constant.](https://stackoverflow.com/a/33007272)

  ```CSharp
  public class AutoGenConfigContainer
  {
    public static AutoGenConfig _ =>
      GenX.defaults.WithGenerator(Gen.Int32(Range.FromValue(13)));
  }

  [Property(typeof(AutoGenConfigContainer))]
  public bool This_test_passes_because_always_13(
    int i) =>
    i == 13;
  ```

#### `Tests` (count)
---
Specifies the number of tests to be run, though more or less may occur due to shrinking or early failure.

```CSharp
[Property(tests: 3)]
public void This_runs_3_times() => _output.WriteLine($"Test run");
```

##### `Size`
---
Sets the `Size` to a value for all runs.

```f#
[<Property(Size = 2)>]
let ``"i" mostly ranges between -1 and 1`` i =
  printfn "%i" i
```

#### Properties attribute
---
This optional attribute can decorate modules or classes. It sets default arguments for [`AutoGenConfig`](#autogenconfig), [`Tests`](#tests-count), [`Shrinks`](#shrinks-count), and [`Size`](#size). These will be overridden by any arguments provided by the `Property` attribute.

```CSharp
public class Int13
{
  public static AutoGenConfig _ => GenX.defaults.WithGenerator(Hedgehog.Gen.constant(13));
}

public class Int2718
{
  public static AutoGenConfig _ => GenX.defaults.WithGenerator(Hedgehog.Gen.constant(2718));
}

[Properties(typeof(Int13),1)]
public class PropertiesSample
{
  [Property]
  public bool this_passes_and_runs_1(
    int i) =>
    i == 13;

  [Property(typeof(Int2718), 2)]
  public bool this_passes_passes_and_runs_twice(
    int i) =>
    i == 2718;
}
```

### Recheck attribute
---
This optional method attribute invokes `Property.recheck` with the given `Size` and `Seed`, it must be used with `Property`.

```CSharp 
[Property]
[Recheck("44_13097736474433561873_6153509253234735533_")]
public bool this_passes_now(int i) =>
  i == 12345;
```

### ParameterGenerator
---
This is the base type of an attribute that can applied property function arguments. It allows you to provide a generator on a parameter by parameter basis.

Lets look at the a property where we want to specify the generator to be used for two integer arguments.
Using a `Property` attribute on this turns out to be quite tricky as we require two different generators for the same type, we may end up with something like [this](/examples/csharp-examples/attribute-based-parameter-comparison/PositiveAndNegativeGeneratorContainerTypes.cs). 


```CSharp
public record PositiveInt(int Value);
public record NegativeInt( int Value );

public class Generators
{
  public static Gen<PositiveInt> GenPositiveInt =>
    from x in Gen.Int32(Range.Constant(1, Int32.MaxValue))
    select new PositiveInt(x);

  public static Gen<NegativeInt> GenNegativeInt =>
    from x in Gen.Int32(Range.Constant(Int32.MinValue, -1))
    select new NegativeInt(x);

  public static AutoGenConfig _ => GenX.defaults
    .WithGenerator(GenPositiveInt)
    .WithGenerator(GenNegativeInt);
}

public class PositiveAndNegativeGeneratorContainerTypes
{
  [Property(typeof(Generators))]
  public bool ResultOfAddingPositiveAndNegativeLessThanPositive(
    PositiveInt positive,
    NegativeInt negative)
    => positive.Value + negative.Value < positive.Value;

}
```

 Using the `ParameterGenerator` attribute is would look like [this](/examples//csharp-examples//attribute-based-parameter-comparison/PositiveAndNegativeSimpleAttribute.cs):

 ```CSharp
public class Negative : ParameterGenerator<int>
{
  public override Gen<int> Generator => Gen.Int32(Range.Constant(Int32.MinValue, -1));
}
public class Positive : ParameterGenerator<int>
{
  public override Gen<int> Generator => Gen.Int32(Range.Constant(1, Int32.MaxValue));
}

public class PositiveAndNegativeUtilizingIntegerRangeAttribute
{
  [Property]
  public bool ResultOfAddingPositiveAndNegativeLessThanPositive(
    [Positive] int positive,
    [Negative] int negative)
    => positive + negative < positive;
}
```

We can also supply parameters to the generator like [so](/examples/csharp-examples/attribute-based-parameter-comparison/PositiveAndNegativeUtilizingIntegerRangeAttribute.cs):

```F#
//Using a parameterised attribute to configure the generators
//Using attributes to configure what generator the property should use
type IntRange(minimum:int32, maximum:int32) =
  inherit ParameterGenerator<int32>()
  override this.Generator = Range.constant minimum maximum |> Gen.int32


[<Property>]
let ``Positive + Negative <= Positive attribute parameterised``
  ([<IntRange(0, System.Int32.MaxValue)>] positive)
  ([<IntRange(System.Int32.MinValue, 0)>] negative) =
  positive + negative <= positive
```
 

The attribute fulfils a very similar function to specifying the [`AutoGenConfig`](#autogenconfig) parameter on the property. If all your tests use the same generators it may be more less code to use [`AutoGenConfig`](#autogenconfig), which can be applied to the [`Properties`](#properties-attribute) attribute.
Parameter generator attributes allow you to easily configure the generator per argument, useful if:  
* A single property has multiple arguments of the same type which require different generators.
* You want to easily configure your generators a per property basis.
* Different properties require different generators.
* You want to be able to see per argument what generator was used. 
 
